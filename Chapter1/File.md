|목차|내용|
|------|---|
|1|[1.Data Files and Index Files](#Data-Files-and-Index-Files)|
|2|[2.Buffering, Immutability, and Ordering](#Buffering-Immutability-and-Ordering)|



# Data Files and Index Files

<img width="317" alt="스크린샷 2024-03-14 오후 2 01 26" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/12251c9f-20d0-4ca4-b36f-79de87ab8be8">


데이터베이스 시스템의 주요 목표는 데이터를 저장하고 빠른 액세스를 허용하는 것이므로, 어떻게 구성해야 하는지 알아봅니다.

데이터베이스 시스템은 데이터를 저장하기 위해 파일을 사용하지만 레코드를 찾기 위해 디렉터리와 파일의 파일 시스템 계층 구조를 의존하는 대신 파일을 구implementation-specific formats으로 구성합니다. 

파일들을 조직적으로 저장하는 이유는 효율성을 늘리기 위함이고, 이는 저장된 각 데이터 레코드 당 overhead를 최소화하는 방식으로 구성됩니다.

효율성은 크게 세 가지로 구분이 되는데, 엑세스 효율성(가능한 적은 단계에서 데이터 찾기), 업데이트 효율성(디스크의 변경 횟수를 최소화) 그리고 앞서 설명한 저장 효율성이다. 

데이터베이스 시스템은 일반적으로 여러 필드로 구성된 데이터 레코드를 테이블에 저장하며 각 테이블은 일반적으로 별도의 파일로 표시됩니다. 

테이블의 각 레코드는 index key를 사용하여 찾을 수 있고,이는 테이블을 매번 액세스할 필요 없이 데이터 레코드를 효율적으로 찾을 수 있게 해주는 보조 데이터 구조입니다. 

인덱스는 레코드를 식별하는 데 사용되는 필드의 하위 집합을 사용하여 작성되며 데이터 파일과 인덱스 파일은 일반적으로 분리된다.

데이터 파일에는 데이터 레코드가 저장되고 인덱스 파일에는 레코드의 meta-data가 저장되어 해당 레코드를 데이터 파일에서 찾을 수 있게 한다.

Data File, Index File,  key등등의 방식이 조직적/구조적으로 저장되어 데이터 저장 / 엑세스/ 업데이트를 효율적으로 빠르게 진행하는 방식 등이 포함되어서 데이터를 관리하는 것을 DBMS라고 한다.

### Data Files

데이터 파일은 인덱스 구성 테이블(IOT), 힙 구성 테이블 또는 해시 구성 테이블로 구현된다.

힙 파일의 레코드는 특정한 순서를 따를 필요가 없으며 대부분의 경우 기록 순서로 배치되기에 새로운 페이지가 추가될 때 별도의 작업이나 파일 재조직이 필요하지 않다. 

<img width="573" alt="스크린샷 2024-03-14 오후 2 01 40" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/29b600c8-31f1-42d4-af62-ca9bd63f4058">

힙 파일은 데이터 레코드가 저장된 위치를 가리키는 추가적인 인덱스 구조가 필요하여 검색 가능하게 만든다.

<img width="553" alt="스크린샷 2024-03-14 오후 2 01 56" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/36451c0e-b479-4e96-bbdb-33c76443e1e4">


해시 파일에서는 레코드가 버킷에 저장되며 키의 해시 값이 레코드가 속한 버킷을 결정하므로, 버킷 내의 레코드는 조회 속도를 향상시키기 위해 추가 순서로 저장되거나 키별로 정렬된다.

<img width="556" alt="스크린샷 2024-03-14 오후 2 02 10" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/b8baf678-5410-443e-8f23-6193659e0c7b">

인덱스 구성 테이블(IOT)에서는 데이터 레코드를 인덱스 자체에 저장하므로 레코드가 키 순서로 저장되므로 IOT에서의 범위 스캔은 내용을 순차적으로 스캔함으로써 구현된다.

데이터 레코드를 인덱스에 저장하면 인덱스를 횡단하고 찾고자 하는 키를 찾은 후에는 연관된 데이터 레코드를 찾기 위해 별도의 파일을 주소 지정할 필요가 없어 최소한 하나의 디스크 탐색을 줄인다.

레코드가 별도의 파일에 저장될 때 인덱스 파일은 데이터 엔트리를 보유하며 데이터 레코드를 고유하게 식별하고 이를 데이터 파일에서 찾을 수 있는 충분한 정보를 포함한다.


**Partitioned IOT**

- 거래일자 기준 Range 파티셔닝
- [상품번호 + 거래일자] 순으로 PK를 정의하고, IOT 구성
        
<img width="492" alt="스크린샷 2024-03-14 오후 2 02 31" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/3e62f786-6c2a-4840-848b-5f87c3daea9f">

**Secondary 인덱스**

① physical guess를 통해 IOT 레코드 access

② PK를 통해 IOT 레코드 access

- 상황에 따라 다른 방식으로 IOT access
- IOT 레코드의 위치는 영구적이지 않기 때문에 secondary index가 IOT 레코드를 가리킬 때 물리적 주소 대신 Logical RowID 사용
- Logical RowID = PK + physical guess

( physical guess: secondary 인덱스를 최초 생성하거나 재생성한 시점에 IOT 레코드가 위치했던 DBA, 갱신X )

<img width="405" alt="스크린샷 2024-03-14 오후 2 02 41" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/a85871e2-cb08-4098-bbc3-57aa0ad2af46">


### Index Files

인덱스는 효율적인 검색 작업을 용이하게 하는 방식으로 디스크에 데이터 레코드를 구성하는 구조이고, 인덱스 파일은 키를 데이터 파일 내의 위치에 매핑하는 특수한 구조로 구성된다.

<img width="566" alt="스크린샷 2024-03-14 오후 2 03 22" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/ecaa4fd1-2636-4b1d-be81-e2b1249adf29">

 이 위치에는 힙 파일의 경우 해당 키로 식별된 레코드 또는 인덱스 구성 테이블의 경우 기본 키(primary keys)가 저장된다.

대부분의 경우 기본 인덱스는 기본 키 또는 기본으로 식별된 키 집합을 기반으로 구성되고, 다른 모든 인덱스는 보조 인덱스(secondary)라고 불립니다.

보조 인덱스는 데이터 레코드를 직접 가리킬 수도 있고 간단히 기본 키를 저장할 수 있으며 데이터 레코드를 가리키는 포인터는 힙 파일이나 인덱스 구성 테이블의 오프셋을 가진다.

여러 보조 인덱스가 동일한 레코드를 가리킬 수 있어 단일 데이터 레코드를 다른 필드로 식별하고 다른 인덱스를 통해 찾을 수 있게 하고, 기본 인덱스 파일은 검색 키 당 고유한 항목을 가지고 있지만, 보조 인덱스는 검색 키 당 여러 항목을 가진다.

<img width="580" alt="스크린샷 2024-03-14 오후 2 03 43" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/bc6eac14-6d44-4524-a929-434f9c192966">

데이터 레코드의 순서가 검색 키 순서를 따를 경우 이 인덱스를 클러스터화(클러스터링)라고 합니다. 클러스터화된 경우 데이터 레코드는 일반적으로 동일한 파일이나 클러스터화된 파일에 저장되며 키 순서가 유지된다.

<img width="560" alt="스크린샷 2024-03-14 오후 2 03 52" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/8237e035-4da2-4a20-b02e-38d65332ba5e">


데이터가 별도의 파일에 저장되고 그 순서가 키 순서를 따르지 않는 경우 인덱스를 클러스터화되지 않은 것이다.

<img width="551" alt="스크린샷 2024-03-14 오후 2 04 05" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/066e3ecc-6ad4-4f68-8b82-27e74111f08e">

많은 데이터베이스 시스템은 내재적이고 명시적인 기본 키를 가지며 데이터베이스 레코드를 고유하게 식별하는 열의 집합이다.

기본 키가 지정되지 않은 경우 저장 엔진은 암시적 기본 키를 생성할 수 있습니다(예: MySQL InnoDB는 새로운 자동 증가 열을 추가하고 그 값을 자동으로 채웁니다).

관계형 데이터베이스 시스템(MySQL 및 PostgreSQL과 같은), Dynamo 기반 NoSQL 스토어(Apache Cassandra 및 Riak), 문서 스토어(MongoDB와 같은)와 같은 여러 종류의 데이터베이스 시스템에서 사용되고,프로젝트별로 특정한 명명이 있을 수 있지만 대부분은 이 용어에 명확하게 매핑된다.

### Primary Index as an Indirection

데이터 레코드를 직접적으로 참조해야 하는지(파일 오프셋을 통해) 아니면 주요 키 인덱스를 통해 참조해야 하는지에 대한 의견이 분분하지만 두 접근 방식은 각자의 장단점이 있으며 전체적인 구현의 범위에서 논의하는 것이 바람직하다.

데이터를 직접 참조하면 디스크 탐색 횟수를 줄일 수 있지만, 레코드가 업데이트되거나 유지보수 과정에서 이동할 때마다 포인터를 업데이트해야 하는 비용이 발생하고, 기본 키 인덱스를 통한 간접 참조는 포인터 업데이트 비용을 줄일 수 있지만 읽기 경로에서 더 높은 비용이 발생한다.

읽기가 주로 포함된 워크로드에서는 몇 개의 인덱스만 업데이트하는 것이 잘 작동할 수 있지만, 여러 인덱스가 있는 쓰기 중심의 워크로드에는 적합하지 않는다. 

몇몇 구현은 페이로드 오프셋 대신 간접 참조에 기본 키를 사용하여 포인터 업데이트 비용을 줄이기도 합니다. 

예를 들어 MySQL InnoDB는 기본 키를 사용하고 조회 시에 보조 인덱스 및 기본 인덱스에서 각각 두 번의 조회를 수행하므로 보조 인덱스에서 직접 오프셋을 따르는 대신 기본 인덱스를 통해 추가적인 비용이 발생합니다

 Figure 1-6은 두 가지 접근 방식이 어떻게 다른지

<img width="532" alt="스크린샷 2024-03-14 오후 2 04 32" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/99092613-1556-4bfe-a6f5-154aa0d3c9d0">

 a) 두 인덱스가 보조 인덱스 파일에서 데이터 엔트리를 직접 참조

 (a) 대 기본 인덱스를 간접 참조로 사용하는 것

 b) 보조 인덱스가 기본 인덱스의 간접 레이어를 통과하여 데이터 엔트리를 찾기.

 (b) 데이터 파일 오프셋과 기본 키를 모두 저장하는 혼합 접근 방식을 사용하여 가능하다.  먼저 데이터 오프셋이 여전히 유효한지 확인하고 변경되었다면 새로운 오프셋을 찾은 후에는 기본 키 인덱스를 통해 추가 비용을 지불하여 인덱스 파일을 업데이트한다.


 <br>

# Buffering, Immutability, and Ordering

Storage Engine은 어떤 데이터 구조를 기반으로 합니다. 그러나 이러한 구조는 캐싱, 회복, 트랜잭션 등과 같은 의미를 설명하지 않습니다. 

이러한 요소들은 저장 엔진이 이러한 구조 위에 추가하는 것입니다. 

다음 장에서는 B-트리 (Ubiquitous B-Trees 참조)로 논의를 시작하고 왜 B-트리의 다양한 변형이 존재하며 새로운 데이터베이스 저장 구조가 계속 등장하는지 설명한다. 

저장 구조에는 세 가지 공통 변수가있는데 버퍼링(또는 그렇지 않은) 사용, 불변(또는 가변) 파일 사용, 값 순서에 따른 저장(또는 무순서)이다.

*아래의 내용은 “그렇구나” 느낌으로 넘어가면 됩니다. 추후에 자세히 다룹니다.*

## Buffering

저장 구조가 어느 정도의 데이터를 디스크에 기록하기 전에 메모리에 수집할지 여부를 정의한다.

디스크와의 데이터 전송의 최소 단위는 블록이며, 완전한 블록을 기록하는 것이 바람직하기 때문 모든 온-디스크 구조는 어느 정도의 버퍼링을 사용한다.

책 초반에 논의하는 최적화 중 하나는 B-트리 노드에 인메모리 버퍼를 추가하여 I/O 비용을 분산시키는 것이지만  버퍼링을 적용하는 유일한 방법은 아니다.

예를 들어 두 구성 요소 LSM 트리(“두 구성 요소 LSM 트리” 참조)는 B-트리와 유사함에도 불구하고 버퍼링을 전혀 다른 방식으로 사용하며 버퍼링을 불변성과 결합

<img width="504" alt="스크린샷 2024-03-14 오후 2 05 04" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/ca29cfbf-d387-4754-8ddb-241f7ca3763d">

## Immutability

저장 구조가 파일의 일부를 읽어들여 업데이트하고 업데이트된 결과를 파일의 동일한 위치에 기록하는지 여부를 정의한다.

불변 구조는 추가 전용으로 한 번 기록되면 파일 내용이 수정되지 않지만  수정 사항은 파일의 끝에 추가된다.

불변성을 구현하는 다른 방법은  복사 시 쓰기(“복사 시 쓰기” 참조)로, 레코드의 업데이트된 버전을 보유한 수정된 페이지가 원래 위치가 아닌 파일의 새 위치에 기록하는 방식이다.

LSM과 B-트리 간의 구분은 주로 불변성 대 업데이트가 있는 저장소로 그려지지만 B-트리를 영감으로 하는 불변 구조인 "BwTrees"와 같은 구조도 있다.

<img width="321" alt="스크린샷 2024-03-14 오후 2 05 12" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/e88ad06a-6822-41ce-b885-a1e4d46f4d61">

## Ordering

데이터 레코드가 디스크의 페이지에서 키 순서대로 저장되는지 여부를 정의한다. 

근접한 키는 디스크의 연속적인 세그먼트에 저장됩니다. 

순서화는 종종 우리가 개별 데이터 레코드를 찾는 것뿐만 아니라 범위의 레코드를 효율적으로 스캔할 수 있는지 여부를 정의합니다. 

데이터를 순서대로 저장하지 않는 경우(대개 삽입 순서로), 쓰기 시간 최적화가 가능해집니다. 

예를 들어 Bitcask(“Bitcask” 참조)와 WiscKey(“WiscKey” 참조)는 데이터 레코드를 직접 추가 전용 파일에 저장합니다. 물론 이 세 가지 개념에 대한 간단한 논의는 그들의 강력함을 보여주기에는 충분하지 않으며, 이 토론은 이 책의 나머지 부분 동안 계속됩니다.

<img width="464" alt="스크린샷 2024-03-14 오후 2 05 20" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/aca90834-fa7c-4226-9610-9473406e57b0">

