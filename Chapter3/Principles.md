
|목차|내용|
|------|---|
|1|[1.General Principles](#General-Principles)|
|2|[2.Page Structure](#Page-Structure)|
|3|[3.Slotted Pages](#Slotted-Pages)|


# General Principles

보통 파일 형식을 설계할 때는 주소 지정 방법을 결정하는 것으로 시작하고, 파일을 동일한 크기의 페이지로 분할할지 여부를 결정하면서  각 페이지는 단일 블록 또는 연속된 여러 블록으로 표현된다. 

In-place 업데이트 저장 구조의 대부분은 읽기 및 쓰기 액세스를 크게 간소화를 위해서 동일한 크기의 페이지를 사용하고,  증분 추가만 가능한 저장 구조는 데이터를 페이지별로 씁니다. 

레코드는 서로 이어붙여지고, 메모리에서 페이지가 가득 차면 디스크에 플러시됩니다. 

- 플러시 예시
    
    로그 기반의 파일 시스템이나 로그 구조화된 데이터베이스에서 사용됩니다.
    
    예를 들어, 로그 기반 파일 시스템에서는 새로운 데이터가 생성될 때마다 파일의 끝에 이어붙이면 이 데이터는 메모리에서 작업 중인 페이지에 일시적으로 저장됩니다.
    
    그렇게 페이지가 메모리에 가득 차면, 해당 페이지의 내용이 디스크에 플러시되어 영구적으로 저장됩니다.
    
    예를 들어, 웹 서버 로그를 기록하는 경우를 상상해보겠습니다. 
    
    새로운 웹 요청이 발생할 때마다 로그는 파일의 끝에 추가되고, 메모리에는 현재 작성 중인 로그 페이지가 있습니다. 
    
    이 페이지에는 여러 웹 요청의 로그가 이어붙여져서 기록되고 메모리의 로그 페이지가 가득 차면, 해당 페이지는 디스크로 플러시되어 로그 파일의 끝에 추가됩니다. 
    
    그런 다음 새로운 로그 페이지가 메모리에 할당되어 쓰기 작업이 계속됩니다.
    
    이러한 방식은 디스크에 쓰기 작업을 최적화하고, 파일 시스템 또는 데이터베이스의 성능을 향상시킬 수 있습니다. 또한 파일의 일부를 오버헤드 없이 추가할 수 있기 때문에 추가 작업이 매우 효율적이다.
    

파일은 보통 고정 크기의 헤더로 시작하고, 중요한 보조 정보를 빠르게 액세스하거나 파일의 나머지 부분을 디코딩하는 데 필요한 고정 크기의 트레일러로 끝나고,  파일의 나머지 부분은 페이지로 나뉜다.

<img width="654" alt="스크린샷 2024-03-14 오후 4 47 10" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/6adf41ba-9e71-4914-ab06-974ca3a09b5a">

많은 데이터 저장소는 고정 스키마를 가지고 있으며, 테이블이 보유할 수 있는 필드의 수, 순서 및 유형을 지정하며 고정된 스키마를 가지는 것은 디스크에 저장되는 데이터 양을 줄이는 데 도움이 됩니다

회사 디렉토리를 위한 형식을 설계하려면 각 직원의 이름, 생년월일, 세금 번호 및 성별을 저장할 수 있고, 여러 가지 방법을 사용할 수 있습니다.  얘를 들어, 고정 크기 필드(예: 생년월일 및 세금 번호)를 구조의 헤드에 저장한 다음 가변 크기 필드를 사용할 수 있습니다.

```
고정 크기 필드:
| (4바이트) 직원 ID |
| (4바이트) 세금 번호 |
| (3바이트) 생일 |
| (1바이트) 성별 |
| (2바이트) 이름 길이 |
| (2바이트) 성 길이 |
가변 크기 필드:
| (이름 길이 바이트) 이름 |
| (성 길이 바이트) 성 |
```

이제 first_name에 액세스하려면 고정 크기 영역 이후의 first_name_length 바이트를 슬라이스할 수 있으며 last_name에 액세스하려면 앞선 가변 크기 필드의 크기를 확인하여 시작 위치를 찾을 수 있습니다. 

이 경우, 모든 가변 크기 필드를 개별적으로 찾을 수 있고, 여러 필드를 포함한 계산을 피하기 위해 고정 크기 영역에 오프셋과 길이를 인코딩할 수 있습니다. 

더 복잡한 구조를 구축하는 것은 일반적으로 계층 구조를 구축하는 것을 의미합니다

기본 요소로 구성된 필드, 필드로 구성된 셀, 셀로 구성된 페이지, 페이지로 구성된 섹션, 섹션으로 구성된 영역 등. 등 있지만  엄격한 규칙은 없으며, 형식을 만들어야 하는 데이터의 종류에 따라 다릅니다.

데이터베이스 파일은 종종 여러 부분으로 구성되며, 나타날 위치를 지원하고 이러한 부분의 시작 오프셋을 가리키는 조회 테이블이 파일 헤더, 트레일러 또는 별도의 파일에 작성됩니다.

# Page Structure

데이터베이스 시스템은 고정 크기의 단위인 페이지로 분할되고 여러 파일 시스템 블록의 크기(4~16KB)를 가지는 데이터 및 인덱스 파일을 데이터 레코드에 저장합니다.

B-트리에서는 키와 데이터 레코드 쌍을 보유하는 리프 노드와 다른 노드를 보유하는 비리프 노드로 구분하는데 

각 B-트리 노드는 하나의 페이지 또는 여러 페이지가 서로 연결된 것을 차지하므로, B-트리의 맥락에서는 노드와 페이지 (심지어 블록까지) 용어가 종종 교환해서 사용됩니다.

원래 B-트리 논문에서는 각 페이지가 키(k), 연관된 값(v), 그리고 자식 페이지로의 포인터(p)의 연결이 단순히 이어진 것으로 묘사하는 고정 크기 데이터 레코드에 대한 단순한 페이지 조직을 설명한다.

<img width="663" alt="스크린샷 2024-03-14 오후 4 47 29" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/c29633e7-da4b-490d-8ef6-2f48d2cb411d">

- 오른쪽 이외의 위치에 키를 추가하는 것은 요소를 재배치해야 합니다.
- 가변 크기 레코드를 효율적으로 관리하거나 액세스하는 데 사용할 수 없으며 고정 크기 데이터에만 사용됩니다.

# Slotted Pages

크기가 m인 레코드가 차지하던 공간에 크기가 n인 레코드를 넣으려고 할 때, m == n이거나 크기가 정확히 m - n인 다른 레코드를 찾을 수 없는 한 이 공간은 사용되지 않은 상태로 남아 있게 되고, 크기가 m인 세그먼트는 k보다 큰 경우에는 k크기의 레코드를 저장하는 데 사용할 수 없으므로 사용되지 않은 공간을 회수하지 않고 삽입됩니다. 이럴 때, 주요 문제는 제거된 레코드가 차지하던 공간을 재사용하는 것입니다. **(가변 크기 레코드 저장 시 이슈)**

가변 크기 레코드의 공간 관리를 간단하게 하기 위해 페이지를 고정 크기 세그먼트로 분할할 순 있지만  공간이 낭비될 수 있습니다.

예를 들어, 세그먼트 크기를 64바이트로 사용하는 경우, 레코드 크기가 64의 배수가 아닌 경우에는 64 - (n 모듈로 64) 바이트가 낭비됩니다. 즉, 레코드가 64의 배수가 아닌 경우 블록 중 하나가 부분적으로만 채워집니다.

공간 회수는 페이지를 간단히 다시 쓰고 레코드를 이동하여 수행할 수 있지만, 페이지 밖의 포인터가 이러한 오프셋을 사용할 수 있기 때문에 레코드 오프셋을 보존해야 합니다. 이를 위해 공간 낭비를 최소화하면서 수행하는 것이 바람직합니다.

요약하면, 다음과 같은 페이지 형식이 필요

- 최소한의 오버헤드로 가변 크기 레코드를 저장
- 제거된 레코드가 차지한 공간을 회수
- 레코드를 페이지에서 정확한 위치에 관계없이 참조

문자열, 이진 대 객체 (BLOB) 등과 같은 가변 크기 레코드를 효율적으로 저장하기 위해 슬롯 페이지  또는 슬롯 디렉터리 조직 기법을 많은 데이터베이스에서 사용되며, 예를 들어 PostgreSQL에서도 사용한다.

페이지를 슬롯이나 셀의 컬렉션으로 구성하고, 페이지의 서로 다른 측면에 있는 독립적인 메모리 영역에 포인터와 셀을 분리하고, 셀을 가리키는 포인터를 재조직하여 순서를 보존하면 레코드를 삭제하는 경우에는 해당 포인터를 무효화하거나 제거함으로써 수행할 수 있습니다. 

슬롯 페이지에는 페이지 및 셀에 대한 중요한 정보를 저장하는 고정 크기 헤더가 있습니다. 

참고로, 셀은 크기가 다를 수 있으며 임의의 데이터를 보유할 수 있습니다: 키, 포인터, 데이터 레코드 등 모든 페이지가 유지 보수 영역 (헤더), 셀 및 그에 대한 포인터로 구성된 슬롯 페이지 조직을 보여줍니다.

<img width="648" alt="스크린샷 2024-03-14 오후 4 47 40" src="https://github.com/sehyun-DBA/Database_internals/assets/160465819/ebf9e0c8-3ad5-4c5b-a29c-7e5f474a99aa">
이 접근 방식이 이 섹션 초반에 언급한 문제들을 어떻게 해결하는지 살펴보겠습니다

1. 최소한의 오버헤드: 슬롯 페이지에 대한 유일한 오버헤드는 레코드가 저장된 정확한 위치를 가리키는 오프셋 보유하는 포인터 배열입니다.
2. 공간 회수: 페이지를 조각내고 다시 쓰는 것으로 공간을 회수할 수 있습니다.
3. 동적 레이아웃: 페이지 외부에서는 슬롯을 그들의 ID로만 참조하므로 정확한 위치는 페이지 내부에 있습니다.

이러한 특징으로 인해 슬롯 페이지는 가변 크기 레코드를 효율적으로 저장하고 관리할 수 있습니다. 추가적으로, 슬롯 페이지는 데이터베이스에서 다양한 용도로 사용될 수 있으며, 데이터베이스의 성능과 공간 활용률을 향상시키는 데 기여할 수 있습니다.
